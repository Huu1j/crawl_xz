# 某luo数据包加密逆向分析-先知社区

> **来源**: https://xz.aliyun.com/news/16714  
> **文章ID**: 16714

---

本文仅用于技术交流

## 准备

app: 5ZOI5ZWwdjYuNzQuMQ==  
设备：cGl4ZWwyIGFuZHJvaWQxMA==

​

## 正文

抓包发现，大部分请求包和返回包都加密了  
例如下面的

![](images/20250104094320-46e3424a-ca3d-1.png)

对于这种，先尝试一手算法自吐脚本 hook一下

但是发现做了frida检测

![](images/20250105130232-4587e9c4-cb22-1.png)

### 绕过检测

下面尝试两种方法绕过  
第一种是使用修改过特征的frida-server   
这里使用的是florida-server  
<https://github.com/Ylarod/Florida>

![](images/20250105204407-c0d68988-cb62-1.png)  
hook后发现没有被杀死  
![](images/20250105204426-cc1a0982-cb62-1.png)

还有一种是找到用于检测的库，在它检测之前nop掉检测函数或者是直接删了这个so库  
详细分析：<https://xz.aliyun.com/t/16185?time__1311=GuD=7IqjOx/D78G7DyjzqoiI++4fO7bD>

脚本

```
function hook_dlopen() {
    Interceptor.attach(Module.findExportByName(null, "android_dlopen_ext"),
        {
            onEnter: function (args) {
                this.fileName = args[0].readCString()
                console.log(`dlopen onEnter: ${this.fileName}`)
            }, onLeave: function (retval) {
                console.log(`dlopen onLeave fileName: ${this.fileName}`)
                if (this.fileName != null && this.fileName.indexOf("libmsaoaidsec.so") >= 0) {
                    let JNI_OnLoad = Module.getExportByName(this.fileName, 'JNI_OnLoad')
                    console.log(`dlopen onLeave JNI_OnLoad: ${JNI_OnLoad}`)
                }
            }
        }
    );
}
```

运行后发现在进入了libmsaoaidsec库后发生进程终止，说明这个库里存在检测机制

![](images/20250105205902-d6509fb8-cb64-1.png)

进入这个app文件夹里删了这个库

![](images/20250105214941-e992f3bc-cb6b-1.png)  
删除了，再启动frida-server就不会被杀掉了

接着使用自吐脚本来hook一下

![](images/20250108200409-ab03692a-cdb8-1.png)

hook一下方法来看看  
代码如下：

```
function hook_encrypt(){
    Java.perform(
        function () {
            var requestCryptoClass = Java.use("com.hellobike.library.encrypt.RequestCrypto");
            requestCryptoClass.encrypt.implementation = function (a) {
                console.log("a==============> ", a);
                var result = this.encrypt(a);
                console.log("result=========> ", result);
                return result;
            }
        }
    )
}
```

对比发现位置找对了  
![](images/20250108232250-6c199a24-cdd4-1.png)

jadx反编译源码搜索encrypt函数，  
这里对genEAS函数的返回结果进行了base64编码，传入的参数src是encrypt接收的字符串，另一个也是字符串  
![](images/20250110000238-263f632e-cea3-1.png)  
查看一下genEAS函数

去掉空值检查和异常处理其实就是用AES算法对输入字符串数据基于给定密钥进行加密并返回加密后的字节数组

![](images/20250110134949-b43a1ba6-cf16-1.png)  
可以跟最基本的javax.crypto包提供的 AES 加密功能实现代码如下：

```
// 将密钥转换为字节数组，使用AES算法创建SecretKeySpec对象
byte[] keyBytes = key.getBytes(StandardCharsets.UTF_8);
SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, "AES");
// 获取Cipher实例，使用默认的加密模式和填充方式（如ECB/PKCS5Padding等，实际应用推荐更安全模式）
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
// 将待加密数据转换为字节数组并进行加密，返回加密后的字节数组
byte[] dataBytes = data.getBytes(StandardCharsets.UTF_8);

```

可以看到genAES函数中填充方式为C8479a.f30298b，键入进去看一下，可以看到这个值为"AES/CBC/PKCS5Padding"

![](images/20250110135213-0a55b20c-cf17-1.png)

钩住genEAS来看看参数和返回值

```
function hook_genAES(){
    Java.perform(
        function (){
            var requestCryptoClass = Java.use("com.hellobike.library.encrypt.RequestCrypto");
            requestCryptoClass.genAES.implementation = function (data, key) {
                console.log("data==============> ", data);
                console.log("key==============> ", key);
                var result = this.genAES(data, key);
                console.log("result=========> ", result);
                return result;
            }
        }
    )
}
```

data就是加密前的数据，key好像是固定的

![](images/20250110231449-a22b5b2e-cf65-1.png)

不过还是得来看看key的生成  
回到encrypt函数中，找到函数m87066a

![](images/20250110140644-112a626a-cf19-1.png)

进入

![](images/20250110140729-2c818fc0-cf19-1.png)

发现m87064m是jni函数

![](images/20250110141345-0c4b5b90-cf1a-1.png)

ida反编译native-lib库  
导出的函数太多，搜索一手l\_m,发现这个m确实是静态注册的

![](images/20250110142915-36cb6ac0-cf1c-1.png)

手动修改一下参数名  
可以看到i为1时，返回值为"1234567890123456657aec76a8c97f98f08f"，为0时则将xmmword\_A8AF0指向的内容处理成字符串  
![](images/20250110231131-2c66c28e-cf65-1.png)

查看xmmword\_A8AF0指向的内容

![](images/20250110231530-bae89d5c-cf65-1.png)  
转换一下，0199bec97dfa5e0d就是上面的key值  
![](images/20250110231638-e34f220c-cf65-1.png)

总结一下，这个加密逻辑很简单，只是aes加密，填充方式为AES/CBC/PKCS5Padding。key是根据传入参数i来决定的，生成key的函数在native层，逻辑也很直接。
